#include "iosurface.h"

uint32_t createSurface() {
    kern_return_t err;

	CFMutableDictionaryRef matching = IOServiceMatching("IOSurfaceRoot");
	if (!matching) {
		printf("Unable to create service matching dictionary\n");
		return 0;
	}

	io_iterator_t iterator;
	err = IOServiceGetMatchingServices(kIOMasterPortDefault, matching, &iterator);

	if (err != KERN_SUCCESS) {
		printf("no matches\n");
		return 0;
	}

	io_service_t service = IOIteratorNext(iterator);

	if (service == IO_OBJECT_NULL) {
		printf("unable to find service\n");
		return 0;
	}
	printf("got service: %x\n", service);

	io_connect_t conn = MACH_PORT_NULL;
	err = IOServiceOpen(service, mach_task_self(), 0, &conn);
	if (err != KERN_SUCCESS) {
		printf("unable to get user client connection\n");
		return 0;
	}
	printf("got user client connection: %x\n", conn);

	char* input_string = "<dict><key>IOSurfaceAllocSize</key><integer>32</integer></dict>";
	create_surface_output_t output_struct;
	size_t output_size = sizeof(output_struct);
	err = IOConnectCallStructMethod(conn, 0,
				    input_string, strlen(input_string) + 1,
				    &output_struct, &output_size);

	if (err != KERN_SUCCESS) {
		printf("Create Surface Failed: %x\n", err);
		return 0;
	} else {
		printf("Successfully Created Surface\n");
	}

	// int * test = (int*)output_struct;

	// for (int i = 0; i < 0x10; i++) {
	// 	printf("i: %x val: %x\n", i, test[i]);
	// }
    return output_struct.data.id;
}